import requests
import socket
import threading
import queue
import re
from concurrent.futures import ThreadPoolExecutor
from utils.helpers import NetworkHelper
from utils.colors import Colors
import time
import ssl
import OpenSSL
from urllib.parse import urlparse, urljoin

class VulnerabilityScanner:
    def __init__(self):
        self.helper = NetworkHelper()
        self.common_ports = [
            21, 22, 23, 25, 53, 80, 81, 110, 111, 135, 139, 143, 443, 445, 
            993, 995, 1723, 3306, 3389, 5900, 8080, 8443
        ]
        self.timeout = 3
        self.threads = 50
        self.results = queue.Queue()
        
    def port_scan(self, target):
        open_ports = []
        port_queue = queue.Queue()
        
        for port in self.common_ports:
            port_queue.put(port)
            
        def scan_port():
            while True:
                try:
                    port = port_queue.get_nowait()
                except queue.Empty:
                    return
                    
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(self.timeout)
                    result = sock.connect_ex((target, port))
                    if result == 0:
                        service = self.identify_service(sock, port)
                        self.results.put((port, service))
                    sock.close()
                except:
                    pass
                    
        threads = []
        for _ in range(self.threads):
            t = threading.Thread(target=scan_port)
            t.start()
            threads.append(t)
            
        for t in threads:
            t.join()
            
        while not self.results.empty():
            port, service = self.results.get()
            open_ports.append((port, service))
            
        return open_ports
        
    def identify_service(self, sock, port):
        common_services = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            443: 'HTTPS',
            3306: 'MySQL',
            3389: 'RDP',
            5900: 'VNC'
        }
        
        if port in common_services:
            try:
                if port == 443:
                    context = ssl.create_default_context()
                    with context.wrap_socket(sock, server_hostname=target) as ssock:
                        cert = ssock.getpeercert()
                        return f"HTTPS (SSL/TLS) - Issuer: {cert['issuer']}"
                else:
                    banner = sock.recv(1024).decode().strip()
                    return f"{common_services[port]} - {banner}"
            except:
                return common_services[port]
        return "Unknown Service"

    def check_sql_injection(self, url):
        payloads = self.load_sql_payloads()
        vulnerabilities = []
        
        def test_payload(payload):
            test_url = f"{url}{payload}"
            try:
                response = requests.get(test_url, timeout=self.timeout)
                content = response.text.lower()
                
                error_patterns = [
                    'sql syntax',
                    'mysql error',
                    'oracle error',
                    'sql server error',
                    'postgresql error',
                    'sqlite error',
                    'database error',
                    'ORA-',
                    'PLS-',
                    'mysql_fetch',
                    'fetch_array',
                    'mysql_result',
                    'mysql_num_rows',
                    'mysql_query',
                    'pg_query',
                    'sql server',
                    'server error in',
                    'warning: mysql'
                ]
                
                for pattern in error_patterns:
                    if pattern in content:
                        self.results.put((payload, pattern))
                        break
                        
                # Time-based detection
                start_time = time.time()
                requests.get(f"{url}{payload.replace('SLEEP(5)', 'SLEEP(10)')}", timeout=15)
                execution_time = time.time() - start_time
                
                if execution_time >= 10:
                    self.results.put((payload, "Time-based SQL injection detected"))
                    
            except requests.Timeout:
                self.results.put((payload, "Potential time-based SQL injection"))
            except:
                pass
                
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(test_payload, payloads)
            
        while not self.results.empty():
            payload, pattern = self.results.get()
            vulnerabilities.append(f"SQL Injection found with payload: {payload} (Pattern: {pattern})")
            
        return vulnerabilities

    def check_xss(self, url):
        payloads = self.load_xss_payloads()
        vulnerabilities = []
        
        def test_payload(payload):
            try:
                # Test GET parameter
                response = requests.get(f"{url}{payload}", timeout=self.timeout)
                if payload in response.text:
                    self.results.put((payload, "GET parameter"))
                    
                # Test POST parameter
                response = requests.post(url, data={'test': payload}, timeout=self.timeout)
                if payload in response.text:
                    self.results.put((payload, "POST parameter"))
                    
                # Test headers
                headers = {'User-Agent': payload, 'Referer': payload}
                response = requests.get(url, headers=headers, timeout=self.timeout)
                if payload in response.text:
                    self.results.put((payload, "HTTP Headers"))
                    
                # Test cookies
                cookies = {'test': payload}
                response = requests.get(url, cookies=cookies, timeout=self.timeout)
                if payload in response.text:
                    self.results.put((payload, "Cookie"))
                    
            except:
                pass
                
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(test_payload, payloads)
            
        while not self.results.empty():
            payload, location = self.results.get()
            vulnerabilities.append(f"XSS vulnerability found with payload: {payload} (Location: {location})")
            
        return vulnerabilities 